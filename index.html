<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chanukode</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Yeseva+One&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
    <style>
        :root {
            --candle-width: 24px;
            --candle-height: 80px;
            --flame-color: #ffd700;
            --candle-color: #e0e0e0;
            --wick-color: #444;
        }
        body {
            min-height: 100vh;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .menorah-wrapper {
            position: relative;
            width: 400px;
            height: 400px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .menorah-svg {
            position: absolute;
            left: 0; top: 0;
            width: 400px; height: 400px;
            z-index: 1;
        }
        .candle {
            position: absolute;
            width: var(--candle-width);
            height: var(--candle-height);
            cursor: pointer;
            pointer-events: all;
            z-index: 2;
        }
        .flame {
            transform-origin: 50% 100%;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .flame.lit {
            opacity: 1;
            animation: flicker 1.5s infinite alternate;
        }
        /* Flicker animation and delays as before */
        .flame1 { animation-delay: 0s; animation-duration: 1.6s; }
        .flame2 { animation-delay: 0.2s; animation-duration: 1.8s; }
        .flame3 { animation-delay: 0.4s; animation-duration: 1.5s; }
        .flame4 { animation-delay: 0.1s; animation-duration: 1.9s; }
        .flame5 { animation-delay: 0.3s; animation-duration: 1.7s; }
        .flame6 { animation-delay: 0.5s; animation-duration: 1.6s; }
        .flame7 { animation-delay: 0.15s; animation-duration: 1.8s; }
        .flame8 { animation-delay: 0.35s; animation-duration: 1.7s; }
        .flame9 { animation-delay: 0.25s; animation-duration: 1.5s; }
        @keyframes flicker {
            0% { transform: scaleY(1) scaleX(1) translateY(0) skewX(0deg); opacity: 1; }
            20% { transform: scaleY(1.03) scaleX(0.98) translateY(-0.5px) skewX(-0.5deg); opacity: 0.98; }
            40% { transform: scaleY(0.98) scaleX(1.01) translateY(0.5px) skewX(0.5deg); opacity: 0.97; }
            60% { transform: scaleY(1.01) scaleX(0.99) translateY(-1px) skewX(-0.3deg); opacity: 0.99; }
            80% { transform: scaleY(0.99) scaleX(1.01) translateY(1px) skewX(0.3deg); opacity: 0.98; }
            100% { transform: scaleY(1) scaleX(1) translateY(0) skewX(0deg); opacity: 1; }
        }
        .candle-body {
            transition: none;
        }
        .candle-wick {
            transition: none;
        }
    </style>
</head>

<body class="yeseva-one-regular">

    <h1>Shalom World!</h1>

    <div class="menorah-wrapper" style="display: flex; gap: 40px; align-items: flex-end; justify-content: center;">
        <div style="position: relative; width: 400px; height: 400px;">
            <svg id="interactive-menorah" viewBox="0 0 400 400" width="400" height="400" style="cursor:pointer;">
                <!-- Ornate Base -->
                <ellipse class="menorah-color" cx="200" cy="370" rx="70" ry="25" fill="#C0C0C0"/>
                <ellipse class="menorah-accent" cx="200" cy="360" rx="50" ry="12" fill="#B0B0B0"/>
                <!-- Central Stem (extended) -->
                <rect class="menorah-color" x="190" y="60" width="20" height="310" fill="#C0C0C0"/>
                <!-- Flared top of central stem -->
                <ellipse class="menorah-color" cx="200" cy="60" rx="16" ry="7" fill="#C0C0C0"/>
                <!-- Branches (left, upward) -->
                <path class="menorah-color" d="M 200 200 C 170 180, 150 150, 145 80" stroke="#C0C0C0" stroke-width="10" fill="none"/>
                <path class="menorah-color" d="M 200 220 C 160 200, 130 160, 120 80" stroke="#C0C0C0" stroke-width="10" fill="none"/>
                <path class="menorah-color" d="M 200 240 C 150 220, 110 170, 95 80" stroke="#C0C0C0" stroke-width="10" fill="none"/>
                <path class="menorah-color" d="M 200 260 C 140 240, 90 190, 70 80" stroke="#C0C0C0" stroke-width="10" fill="none"/>
                <!-- Branches (right, upward) -->
                <path class="menorah-color" d="M 200 200 C 230 180, 250 150, 255 80" stroke="#C0C0C0" stroke-width="10" fill="none"/>
                <path class="menorah-color" d="M 200 220 C 240 200, 270 160, 280 80" stroke="#C0C0C0" stroke-width="10" fill="none"/>
                <path class="menorah-color" d="M 200 240 C 250 220, 290 170, 305 80" stroke="#C0C0C0" stroke-width="10" fill="none"/>
                <path class="menorah-color" d="M 200 260 C 260 240, 310 190, 330 80" stroke="#C0C0C0" stroke-width="10" fill="none"/>
                <!-- Candle Holders -->
                <rect class="menorah-color" x="192" y="60" width="16" height="20" fill="#C0C0C0"/>
                <ellipse class="menorah-color" cx="200" cy="60" rx="10" ry="6" fill="#C0C0C0"/>
                <!-- Left holders -->
                <ellipse class="menorah-color" cx="70" cy="80" rx="10" ry="6" fill="#C0C0C0"/>
                <ellipse class="menorah-color" cx="95" cy="80" rx="10" ry="6" fill="#C0C0C0"/>
                <ellipse class="menorah-color" cx="120" cy="80" rx="10" ry="6" fill="#C0C0C0"/>
                <ellipse class="menorah-color" cx="145" cy="80" rx="10" ry="6" fill="#C0C0C0"/>
                <!-- Right holders -->
                <ellipse class="menorah-color" cx="330" cy="80" rx="10" ry="6" fill="#C0C0C0"/>
                <ellipse class="menorah-color" cx="305" cy="80" rx="10" ry="6" fill="#C0C0C0"/>
                <ellipse class="menorah-color" cx="280" cy="80" rx="10" ry="6" fill="#C0C0C0"/>
                <ellipse class="menorah-color" cx="255" cy="80" rx="10" ry="6" fill="#C0C0C0"/>
            </svg>
            <input type="color" id="menorah-color-picker" style="display:none; opacity:0; pointer-events:none; position:absolute;" />
            <input type="color" id="candle-color-picker" style="display:none; opacity:0; pointer-events:none; position:absolute;" />
            <!-- Candles will be injected here by JS -->
        </div>
    </div>
    <script>
        // Candle positions (left, top) for each holder
        const candlePositions = [
            { left: 58, top: 10 },
            { left: 83, top: 10 },
            { left: 108, top: 10 },
            { left: 133, top: 10 },
            { left: 188, top: 0 },   // Shamash
            { left: 243, top: 10 },
            { left: 268, top: 10 },
            { left: 293, top: 10 },
            { left: 318, top: 10 }
        ];
        const wrapper = document.querySelector('.menorah-wrapper');
        // Assign indices for right-to-left lighting order based on left position
        const candleMeta = candlePositions
            .map((pos, i) => ({ pos, i }))
            .filter(obj => obj.i !== 4) // exclude shamash
            .sort((a, b) => b.pos.left - a.pos.left)
            .map((obj, idx) => ({ ...obj, candleIdx: idx }));
        candlePositions.forEach((pos, i) => {
            if (i === 4) {
                // Shamash: use a wrapper div for drag-and-drop
                const shamashDiv = document.createElement('div');
                shamashDiv.className = 'shamash-wrapper candle';
                shamashDiv.style.position = 'absolute';
                shamashDiv.style.left = pos.left + 'px';
                shamashDiv.style.top = pos.top + 'px';
                shamashDiv.style.width = '24px';
                shamashDiv.style.height = '80px';
                shamashDiv.style.zIndex = 10;
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('viewBox', '0 0 24 80');
                svg.classList.add('shamash-svg');
                svg.innerHTML = `
                    <rect class="candle-body" x="4" y="20" width="16" height="48" rx="4" fill="#e0e0e0"/>
                    <rect class="candle-wick" x="11" y="16" width="2" height="8" rx="1" fill="#444"/>
                    <ellipse class="flame flame${i+1}" cx="12" cy="12" rx="4" ry="8" fill="#ffd700"/>
                `;
                shamashDiv.appendChild(svg);
                wrapper.appendChild(shamashDiv);
            } else {
                // Find the correct candleIdx for this position
                const meta = candleMeta.find(obj => obj.i === i);
                const candleIdx = meta ? meta.candleIdx : -1;
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('class', 'candle');
                svg.setAttribute('data-candle-idx', candleIdx);
                svg.setAttribute('viewBox', '0 0 24 80');
                svg.setAttribute('style', `left:${pos.left}px;top:${pos.top}px;`);
                svg.innerHTML = `
                    <rect class="candle-body" x="4" y="20" width="16" height="48" rx="4" fill="#e0e0e0"/>
                    <rect class="candle-wick" x="11" y="16" width="2" height="8" rx="1" fill="#444"/>
                    <ellipse class="flame flame${i+1}" cx="12" cy="12" rx="4" ry="8" fill="#ffd700"/>
                `;
                wrapper.appendChild(svg);
            }
        });
        // Drag and drop for shamash
        let dragTarget = null;
        let offsetX = 0, offsetY = 0;
        let dragging = false;
        let wasDragged = false;
        let holdTimer = null;
        let lastHoveredCandle = null;
        wrapper.addEventListener('mousedown', function(e) {
            const shamashDiv = wrapper.querySelector('.shamash-wrapper');
            if (e.target.closest('.shamash-wrapper')) {
                dragTarget = shamashDiv;
                const rect = shamashDiv.getBoundingClientRect();
                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;
                dragging = true;
                document.body.style.userSelect = 'none';
                wasDragged = false;
                // Reset hold-to-light state
                if (holdTimer) { clearTimeout(holdTimer); holdTimer = null; }
                lastHoveredCandle = null;
            }
        });
        document.addEventListener('mousemove', function(e) {
            if (dragTarget && dragging) {
                const wrapperRect = wrapper.getBoundingClientRect();
                let x = e.clientX - wrapperRect.left - offsetX;
                let y = e.clientY - wrapperRect.top - offsetY;
                // Clamp within wrapper
                x = Math.max(0, Math.min(wrapper.offsetWidth - 24, x));
                y = Math.max(0, Math.min(wrapper.offsetHeight - 80, y));
                dragTarget.style.left = x + 'px';
                dragTarget.style.top = y + 'px';
                wasDragged = true;
                // On drag, check for overlap between shamash flame and any unlit candle wick
                const shamashDiv = wrapper.querySelector('.shamash-wrapper');
                const shamashFlame = shamashDiv.querySelector('.flame');
                if (shamashFlame && shamashFlame.classList.contains('lit')) {
                    const flameRect = shamashFlame.getBoundingClientRect();
                    let hoveredCandle = null;
                    // Get all non-shamash candles, rightmost first
                    const candles = Array.from(wrapper.querySelectorAll('svg.candle'));
                    // Sort by data-candle-idx ascending (rightmost first)
                    candles.sort((a, b) => parseInt(a.getAttribute('data-candle-idx')) - parseInt(b.getAttribute('data-candle-idx')));
                    // Find the rightmost unlit candle (lowest index)
                    let rightmostUnlit = null;
                    for (const candle of candles) {
                        const flame = candle.querySelector('.flame');
                        if (flame && !flame.classList.contains('lit')) {
                            rightmostUnlit = candle;
                            break;
                        }
                    }
                    candles.forEach((candle) => {
                        const rects = candle.querySelectorAll('rect');
                        const wick = rects[1];
                        const flame = candle.querySelector('.flame');
                        // Only allow lighting the rightmost unlit candle
                        if (wick && flame && candle === rightmostUnlit && !flame.classList.contains('lit')) {
                            const wickRect = wick.getBoundingClientRect();
                            if (!(flameRect.right < wickRect.left ||
                                  flameRect.left > wickRect.right ||
                                  flameRect.bottom < wickRect.top ||
                                  flameRect.top > wickRect.bottom)) {
                                hoveredCandle = candle;
                            }
                        }
                    });
                    // If hovering a new candle, start timer
                    if (hoveredCandle !== lastHoveredCandle) {
                        if (holdTimer) { clearTimeout(holdTimer); holdTimer = null; }
                        lastHoveredCandle = hoveredCandle;
                        if (hoveredCandle) {
                            holdTimer = setTimeout(() => {
                                const flame = hoveredCandle.querySelector('.flame');
                                if (flame && !flame.classList.contains('lit')) {
                                    flame.classList.add('lit');
                                    startBurning(hoveredCandle);
                                }
                                holdTimer = null;
                                lastHoveredCandle = null;
                            }, 1000);
                        }
                    }
                    // If not hovering any candle, clear timer
                    if (!hoveredCandle && holdTimer) {
                        clearTimeout(holdTimer); holdTimer = null; lastHoveredCandle = null;
                    }
                } else {
                    // If shamash is not lit, clear timer
                    if (holdTimer) { clearTimeout(holdTimer); holdTimer = null; lastHoveredCandle = null; }
                }
            }
        });
        document.addEventListener('mouseup', function() {
            dragTarget = null;
            dragging = false;
            document.body.style.userSelect = '';
            if (holdTimer) { clearTimeout(holdTimer); holdTimer = null; lastHoveredCandle = null; }
        });
        // Event delegation for toggling flames
        wrapper.addEventListener('click', function(e) {
            if (dragging) {
                e.stopPropagation();
                e.preventDefault();
                return;
            }
            // For shamash, flame is inside the SVG in the wrapper
            if (e.target.closest('.shamash-wrapper')) {
                if (wasDragged) {
                    wasDragged = false;
                    return;
                }
                const flame = e.target.closest('.shamash-wrapper').querySelector('.flame');
                if (flame) flame.classList.toggle('lit');
                return;
            }
            // For other candles, open color picker and change color (do not toggle flame)
            const candleSvg = e.target.closest('svg.candle');
            if (candleSvg) {
                currentCandleForColor = candleSvg;
                candleColorPicker.value = rgbToHex(candleSvg.querySelector('.candle-body').getAttribute('fill') || '#e0e0e0');
                // Position the color picker near the candle
                const candleRect = candleSvg.getBoundingClientRect();
                const wrapperRect = wrapper.getBoundingClientRect();
                candleColorPicker.style.position = 'absolute';
                candleColorPicker.style.left = (candleRect.left - wrapperRect.left + candleRect.width / 2 - 15) + 'px';
                candleColorPicker.style.top = (candleRect.top - wrapperRect.top - 36) + 'px';
                candleColorPicker.style.display = 'block';
                candleColorPicker.click();
                return;
            }
        });
        // Add burn-down animation when a candle is lit (JS-driven)
        function startBurning(candle) {
            if (candle._burning) return;
            candle._burning = true;
            const body = candle.querySelector('.candle-body');
            const wick = candle.querySelector('.candle-wick');
            const flame = candle.querySelector('.flame');
            let bodyHeight = 48, bodyY = 20;
            let wickHeight = 8, wickY = 16;
            let flameCy = 12;
            const burnDuration = 30000; // ms (was 12000)
            const steps = 60;
            let step = 0;
            const bodyHeightStep = bodyHeight / steps;
            const bodyYStep = (68 - bodyY) / steps;
            const wickHeightStep = wickHeight / steps;
            const wickYStep = (68 - wickY) / steps;
            const flameCyStep = (68 - flameCy) / steps;
            const svg = candle.tagName === 'svg' ? candle : candle.querySelector('svg');
            function animate() {
                if (!flame.classList.contains('lit')) {
                    candle._burning = false;
                    return;
                }
                if (step >= steps) {
                    body.setAttribute('height', 0);
                    body.setAttribute('y', 68);
                    wick.setAttribute('height', 0);
                    wick.setAttribute('y', 68);
                    flame.setAttribute('cy', 68);
                    flame.classList.remove('lit');
                    candle._burning = false;
                    // Add smoke effect
                    createSmoke(svg, 68);
                    return;
                }
                body.setAttribute('height', Math.max(0, bodyHeight - bodyHeightStep * step));
                body.setAttribute('y', bodyY + bodyYStep * step);
                wick.setAttribute('height', Math.max(0, wickHeight - wickHeightStep * step));
                wick.setAttribute('y', wickY + wickYStep * step);
                flame.setAttribute('cy', flameCy + flameCyStep * step);
                step++;
                setTimeout(animate, burnDuration / steps);
            }
            animate();
        }

        // Smoke effect function
        function createSmoke(svg, y) {
            // Continuous smoke trail as a path
            const points = [];
            const numPoints = 18;
            const baseX = 12;
            let baseY = y - 8;
            for (let i = 0; i < numPoints; i++) {
                points.push({
                    x: baseX,
                    y: baseY - i * 3,
                    alpha: 1 - i / numPoints
                });
            }
            const smokePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            smokePath.setAttribute('stroke', '#bbb');
            smokePath.setAttribute('stroke-width', '2');
            smokePath.setAttribute('fill', 'none');
            smokePath.setAttribute('opacity', '0.7');
            svg.appendChild(smokePath);
            let frame = 0;
            const frames = 300;
            function animateSmokeTrail() {
                // Animate the points upward, add waviness, fade out
                for (let i = 0; i < points.length; i++) {
                    points[i].y -= 0.7 + 0.1 * i;
                    points[i].x = baseX + Math.sin(frame / 10 + i * 0.7) * (2 + i * 0.2);
                }
                // Build the path string
                let d = `M ${points[0].x} ${points[0].y}`;
                for (let i = 1; i < points.length; i++) {
                    d += ` L ${points[i].x} ${points[i].y}`;
                }
                smokePath.setAttribute('d', d);
                // Fade out
                smokePath.setAttribute('opacity', Math.max(0, 0.7 - frame * 0.0033));
                frame++;
                if (frame < frames) {
                    requestAnimationFrame(animateSmokeTrail);
                } else {
                    smokePath.remove();
                }
            }
            animateSmokeTrail();
        }
        // Candle color picker logic
        const candleColorPicker = document.getElementById('candle-color-picker');
        let currentCandleForColor = null;
        wrapper.addEventListener('click', function(e) {
            if (dragging) {
                e.stopPropagation();
                e.preventDefault();
                return;
            }
            // For shamash, flame is inside the SVG in the wrapper
            if (e.target.closest('.shamash-wrapper')) {
                if (wasDragged) {
                    wasDragged = false;
                    return;
                }
                const flame = e.target.closest('.shamash-wrapper').querySelector('.flame');
                if (flame) flame.classList.toggle('lit');
                return;
            }
            // For other candles, open color picker and change color (do not toggle flame)
            const candleSvg = e.target.closest('svg.candle');
            if (candleSvg) {
                currentCandleForColor = candleSvg;
                candleColorPicker.value = rgbToHex(candleSvg.querySelector('.candle-body').getAttribute('fill') || '#e0e0e0');
                // Position the color picker near the candle
                const candleRect = candleSvg.getBoundingClientRect();
                const wrapperRect = wrapper.getBoundingClientRect();
                candleColorPicker.style.position = 'absolute';
                candleColorPicker.style.left = (candleRect.left - wrapperRect.left + candleRect.width / 2 - 15) + 'px';
                candleColorPicker.style.top = (candleRect.top - wrapperRect.top - 36) + 'px';
                candleColorPicker.style.display = 'block';
                candleColorPicker.click();
                return;
            }
        });
        candleColorPicker.addEventListener('input', function() {
            if (currentCandleForColor) {
                const color = candleColorPicker.value;
                const body = currentCandleForColor.querySelector('.candle-body');
                if (body) body.setAttribute('fill', color);
                currentCandleForColor = null;
            }
            candleColorPicker.style.display = 'none';
        });
        candleColorPicker.addEventListener('blur', function() {
            candleColorPicker.style.display = 'none';
        });

        // Menorah color picker logic
        const menorahSvg = document.getElementById('interactive-menorah');
        const colorPicker = document.getElementById('menorah-color-picker');
        menorahSvg.addEventListener('click', function(e) {
            // Position the color picker very close to the top center of the menorah SVG (just above y=60)
            const svgRect = menorahSvg.getBoundingClientRect();
            const wrapperRect = wrapper.getBoundingClientRect();
            // The top ellipse is at y=60 in SVG coordinates, so find its screen position
            // SVG viewBox is 0 0 400 400, so scale factor is svgRect.height/400
            const scaleY = svgRect.height / 400;
            const scaleX = svgRect.width / 400;
            const ellipseY = 60 * scaleY; // y=60 in SVG
            const ellipseX = 200 * scaleX; // center x=200 in SVG
            colorPicker.style.position = 'absolute';
            colorPicker.style.left = (svgRect.left - wrapperRect.left + ellipseX - 15) + 'px';
            colorPicker.style.top = (svgRect.top - wrapperRect.top + ellipseY - 30) + 'px'; // 10px above ellipse
            colorPicker.style.display = 'block';
            colorPicker.click();
        });
        colorPicker.addEventListener('input', function() {
            const color = colorPicker.value;
            menorahSvg.querySelectorAll('.menorah-color').forEach(el => {
                if (el.tagName === 'path') {
                    el.setAttribute('stroke', color);
                } else {
                    el.setAttribute('fill', color);
                }
            });
            colorPicker.style.display = 'none';
        });
        colorPicker.addEventListener('blur', function() {
            colorPicker.style.display = 'none';
        });
        // Helper to convert rgb to hex
        function rgbToHex(rgb) {
            if (!rgb) return '#e0e0e0';
            if (rgb[0] === '#') return rgb;
            const result = rgb.match(/\d+/g);
            if (!result) return '#e0e0e0';
            return '#' + result.slice(0, 3).map(x => (+x).toString(16).padStart(2, '0')).join('');
        }
    </script>
    <script src="app.js"></script>
</body>

</html>